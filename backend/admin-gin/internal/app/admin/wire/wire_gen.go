// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package wire

import (
	"github.com/google/wire"
	"github.com/redis/go-redis/v9"
	"gorm.io/gorm"
	"mall-api/internal/app/admin/iam/auth"
	"mall-api/internal/app/admin/user"
)

// Injectors from wire.go:

// InitAdminHandlers wires up all admin handlers.
// Keep db/rdb provided by your bootstrap layer; wire only builds module graph.
func InitAdminHandlers(db *gorm.DB, rdb *redis.Client) (*AdminHandlers, error) {
	repository := auth.NewRepository(db)
	service := auth.NewService(repository)
	handler := auth.NewHandler(service)
	userRepository := user.NewRepository(db)
	userService := user.NewService(userRepository)
	userHandler := user.NewHandler(userService)
	adminHandlers := &AdminHandlers{
		Auth: handler,
		User: userHandler,
	}
	return adminHandlers, nil
}

// wire.go:

// AdminHandlers is the admin-module handler set resolved by Wire.
// Router registration should depend on these handlers rather than constructing them inside router funcs.
type AdminHandlers struct {
	Auth *auth.Handler
	User *user.Handler
}

// Provider sets for each module (repo -> service -> handler).
//
// Note:
//   - Wire can use concrete provider functions directly.
//   - `wire.Bind` is only needed when you provide a concrete type and want to satisfy an interface,
//     but here `NewService` takes the interface type already, so extra bindings are unnecessary.
var (
	authSet = wire.NewSet(auth.NewRepository, auth.NewService, auth.NewHandler)

	userSet = wire.NewSet(user.NewRepository, user.NewService, user.NewHandler)

	adminSet = wire.NewSet(
		authSet,
		userSet, wire.Struct(new(AdminHandlers), "Auth", "User"),
	)
)
